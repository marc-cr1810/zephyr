# Zephyr Concurrency Issue Demonstration
# This test clearly shows that async operations are NOT running concurrently

print("=== Concurrency Issue Demonstration ===")
print("")

# ============================================================================
# Test 1: Sequential vs "Parallel" Execution Should Show Different Patterns
# ============================================================================

print("1. Execution Pattern Test")
print("==========================")

async func slow_task(task_id, steps) {
    print("TASK", task_id, "STARTED")

    for i = 1; i <= steps; i++ {
        print("TASK", task_id, "- Step", i, "of", steps)

        # Simulate async work that should yield control
        # In true async, this would be an await point where other tasks could run
        counter = 0
        for j = 0; j < 500000; j++ {
            counter += 1
        }
    }

    print("TASK", task_id, "COMPLETED")
    return "Task " + str(task_id) + " result"
}

print("\n--- Sequential Execution (Expected Pattern) ---")
print("Each task should complete fully before the next starts:")

result1 = await slow_task(1, 3)
result2 = await slow_task(2, 3)
result3 = await slow_task(3, 3)

print("Sequential results:", [result1, result2, result3])

print("\n--- 'Parallel' Execution with spawn (BROKEN - Should Interleave) ---")
print("Tasks should START together and INTERLEAVE their steps:")
print("Expected: TASK 1 STARTED, TASK 2 STARTED, TASK 3 STARTED, then interleaved steps")
print("Actual output below:")

promise1 = spawn slow_task(4, 3)
promise2 = spawn slow_task(5, 3)
promise3 = spawn slow_task(6, 3)

print("^^^ All spawn calls completed (this line should appear AFTER all tasks start)")

par_result1 = await promise1
par_result2 = await promise2
par_result3 = await promise3

print("Parallel results:", [par_result1, par_result2, par_result3])

# ============================================================================
# Test 2: Promise.all Should Show True Concurrency
# ============================================================================

print("\n2. Promise.all Concurrency Test")
print("=================================")
print("With true async, all tasks should start immediately and interleave:")

all_promises = [
    spawn slow_task(7, 2),
    spawn slow_task(8, 2),
    spawn slow_task(9, 2)
]

print("^^^ All spawn calls for Promise.all completed")
print("In true async, we should see:")
print("  TASK 7 STARTED")
print("  TASK 8 STARTED")
print("  TASK 9 STARTED")
print("  TASK 7 - Step 1 of 2")
print("  TASK 8 - Step 1 of 2")
print("  TASK 9 - Step 1 of 2")
print("  ... etc (interleaved)")

all_results = await all(all_promises)
print("Promise.all results:", all_results)

# ============================================================================
# Test 3: The "Async" Illusion - Showing It's Actually Synchronous
# ============================================================================

print("\n3. The Async Illusion Test")
print("============================")
print("This test proves execution is synchronous, not concurrent:")

async func quick_task(id) {
    print("Quick task", id, "executing")
    return "Quick " + str(id)
}

async func long_task(id) {
    print("Long task", id, "started")

    # Long work
    counter = 0
    for i = 0; i < 2000000; i++ {
        counter += 1
    }

    print("Long task", id, "finished")
    return "Long " + str(id)
}

print("\nSpawning tasks in this order: LONG, QUICK, LONG")
print("If truly concurrent, QUICK should finish before second LONG")
print("If synchronous (current), they'll finish in spawn order")

long_promise1 = spawn long_task(1)
quick_promise = spawn quick_task(1)
long_promise2 = spawn long_task(2)

print("All tasks spawned - checking results:")

# Await in different order to show the issue
quick_result = await quick_promise    # This should be fast
long_result1 = await long_promise1    # This was spawned first
long_result2 = await long_promise2    # This was spawned last

print("Results:", [quick_result, long_result1, long_result2])

# ============================================================================
# Test 4: What SHOULD Happen - Cooperative Multitasking Demo
# ============================================================================

print("\n4. What SHOULD Happen (Conceptual)")
print("===================================")
print("In proper async/await (like Python/JavaScript):")
print("")
print("spawn task_a()  # Starts task_a, returns pending promise")
print("spawn task_b()  # Starts task_b, returns pending promise")
print("spawn task_c()  # Starts task_c, returns pending promise")
print("")
print("# All tasks are now running concurrently!")
print("# They yield control at await points")
print("# Execution interleaves between tasks")
print("")
print("await promise_a  # Waits only for task_a to complete")
print("# task_b and task_c continue running in background")

# ============================================================================
# Test 5: Real-World Impact
# ============================================================================

print("\n5. Real-World Impact of This Issue")
print("====================================")
print("Current behavior makes async/await almost useless because:")
print("1. No performance benefit - everything runs sequentially")
print("2. Can't overlap I/O operations")
print("3. Can't build responsive UIs")
print("4. Defeats the main purpose of async programming")
print("")
print("Example: fetching from 3 APIs")

async func fetch_api(api_name, delay_sim) {
    print("Fetching from", api_name, "API...")

    # Simulate network delay
    counter = 0
    for i = 0; i < delay_sim; i++ {
        counter += 1
    }

    print("Response from", api_name, "API received")
    return api_name + " data"
}

print("\nWith current (broken) implementation:")
print("Each API call blocks until complete - NO CONCURRENCY")

api_promises = [
    spawn fetch_api("Users", 1000000),
    spawn fetch_api("Posts", 800000),
    spawn fetch_api("Comments", 1200000)
]

api_results = await all(api_promises)
print("API results:", api_results)

print("\nWith proper async (what should happen):")
print("All API calls would start immediately and run concurrently")
print("Total time = max(individual times), not sum(individual times)")

print("\n=== SUMMARY ===")
print("ðŸ”´ ISSUE: spawn executes immediately and synchronously")
print("ðŸ”´ ISSUE: No cooperative multitasking or yielding")
print("ðŸ”´ ISSUE: await returns immediately (promises already resolved)")
print("ðŸŸ¢ NEEDED: True cooperative concurrency in single thread")
print("ðŸŸ¢ NEEDED: Tasks should yield at await points")
print("ðŸŸ¢ NEEDED: spawn should return pending promises")
