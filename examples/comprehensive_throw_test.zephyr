# Comprehensive Throw Test
# This demonstrates Zephyr's ability to throw and catch ANY object type,
# not just exception objects, providing maximum flexibility

print("=== Comprehensive Throw Test - Any Object Can Be Thrown ===")
print()

# Test 1: Primitive Types
print("Test 1: Throwing Primitive Types")

# Integer
try {
    throw 42
} catch (val) {
    print("Integer 42:", val, "- can do math:", val + 8)
}

# Float
try {
    throw 3.14159
} catch (val) {
    print("Float Ï€:", val, "- doubled:", val * 2)
}

# String
try {
    throw "Hello, World!"
} catch (msg) {
    print("String:", msg, "- length:", len(msg))
}

# Boolean
try {
    throw false
} catch (flag) {
    print("Boolean:", flag, "- negated:", not flag)
}

# None
try {
    throw none
} catch (nil) {
    print("None:", nil, "- is none:", nil == none)
}
print()

# Test 2: Collections
print("Test 2: Throwing Collections")

# List
try {
    throw [1, 2, 3, "mixed", true]
} catch (arr) {
    print("List:", arr)
    print("  Length:", len(arr))
    print("  Elements:")
    for i in range(len(arr)) {
        print("    [" + str(i) + "]:", arr[i])
    }
}

# Dictionary
try {
    data = {"name": "Alice", "age": 30, "active": true}
    throw data
} catch (obj) {
    print("Dictionary:", obj)
    print("  Name:", obj["name"])
    print("  Age:", obj["age"])
    print("  Active:", obj["active"])
}
print()

# Test 3: Functions as Thrown Objects
print("Test 3: Throwing Functions")

func greet(name) {
    return "Hello, " + name + "!"
}

try {
    throw greet
} catch (func_obj) {
    print("Caught function:", func_obj)
    print("Calling function:", func_obj("Bob"))
}

# Lambda functions
try {
    square = x -> x * x
    throw square
} catch (lambda_func) {
    print("Caught lambda:", lambda_func)
    print("Lambda result for 7:", lambda_func(7))
}
print()

# Test 4: Custom Classes
print("Test 4: Throwing Custom Objects")

class Person {
    func __init__(name, age, city) {
        self.name = name
        self.age = age
        self.city = city
    }

    func introduce() {
        return "Hi, I'm " + self.name + ", " + str(self.age) + " years old from " + self.city
    }

    func birthday() {
        self.age = self.age + 1
        return "Happy birthday! Now " + str(self.age)
    }
}

class ErrorInfo {
    func __init__(code, message, severity) {
        self.code = code
        self.message = message
        self.severity = severity
        self.timestamp = "2024-01-01T12:00:00"
    }

    func to_string() {
        return "[" + self.severity + "] " + str(self.code) + ": " + self.message
    }
}

try {
    person = Person("Charlie", 25, "New York")
    throw person
} catch (p) {
    print("Caught person:", p.name)
    print("Introduction:", p.introduce())
    print("After birthday:", p.birthday())
}

try {
    error = ErrorInfo(404, "Resource not found", "ERROR")
    throw error
} catch (err) {
    print("Caught error info:")
    print("  Code:", err.code)
    print("  Message:", err.message)
    print("  Severity:", err.severity)
    print("  String form:", err.to_string())
}
print()

# Test 5: Complex Nested Structures
print("Test 5: Throwing Complex Nested Structures")

try {
    complex_data = {
        "user": {"name": "Diana", "id": 123},
        "permissions": ["read", "write"],
        "metadata": {
            "created": "2024-01-01",
            "version": 2.1,
            "active": true
        },
        "calculate": (x, y) -> x + y
    }
    throw complex_data
} catch (data) {
    print("Complex object caught:")
    print("  User name:", data["user"]["name"])
    print("  User ID:", data["user"]["id"])
    print("  Permissions:", data["permissions"])
    print("  Version:", data["metadata"]["version"])
    print("  Calculation (5+3):", data["calculate"](5, 3))
}
print()

# Test 6: Mixing with Real Exception Objects
print("Test 6: Mixed with Real Exception Objects")

func throw_random_thing(type_choice) {
    if type_choice == "exception" {
        throw RuntimeError("This is a real exception object")
    } else if type_choice == "number" {
        throw 999
    } else if type_choice == "text" {
        throw "Just a plain string"
    } else if type_choice == "data" {
        throw {"error": true, "details": "Something went wrong"}
    } else {
        throw ["unknown", "error", "type"]
    }
}

test_types = ["exception", "number", "text", "data", "other"]

for test_type in test_types {
    print("Testing type:", test_type)
    try {
        throw_random_thing(test_type)
    } catch (e as RuntimeError) {
        print("  â†’ Caught as RuntimeError:", e.message)
    } catch (e as IndexError) {
        print("  â†’ Caught as IndexError:", e.message)
    } catch (val) {
        print("  â†’ Caught as generic object:", val)
        print("    Type:", type(val))

        # Demonstrate we can operate on any caught object
        if type(val) == "int" {
            print("    Math operation:", val * 2)
        } else if type(val) == "string" {
            print("    String operation:", len(val), "characters")
        } else if type(val) == "dictionary" {
            print("    Dictionary keys:", keys(val))
        } else if type(val) == "list" {
            print("    List length:", len(val))
        }
    }
    print("    ---")
}
print()

# Test 7: Practical Use Cases
print("Test 7: Practical Use Cases for Throwing Non-Exceptions")

# Use case 1: Returning complex error information
func process_request(request_data) {
    if request_data == none {
        # Throw detailed error information as an object
        throw {
            "error_type": "validation_error",
            "field": "request_data",
            "message": "Request data cannot be none",
            "suggestion": "Provide valid request data",
            "error_code": 400
        }
    }

    if not ("id" in request_data) {
        throw {
            "error_type": "missing_field",
            "field": "id",
            "message": "Request must include an ID field",
            "suggestion": "Add 'id' field to request",
            "error_code": 422
        }
    }

    return "Request processed: " + str(request_data["id"])
}

test_requests = [
    none,
    {"name": "test"},
    {"id": 123, "name": "valid"}
]

for i in range(len(test_requests)) {
    request = test_requests[i]
    print("Processing request", i + 1, ":", request)

    try {
        result = process_request(request)
        print("  âœ“ Success:", result)
    } catch (error_info) {
        print("  âœ— Error:", error_info["error_type"])
        print("    Field:", error_info["field"])
        print("    Message:", error_info["message"])
        print("    Code:", error_info["error_code"])
        print("    Suggestion:", error_info["suggestion"])
    }
}
print()

# Use case 2: Throwing function results or objects for control flow
func get_processor(operation_type) {
    if operation_type == "add" {
        return (a, b) -> a + b
    } else if operation_type == "multiply" {
        return (a, b) -> a * b
    } else {
        # Throw the default processor
        throw (a, b) -> a - b
    }
}

operations = ["add", "multiply", "unknown"]

for op in operations {
    print("Getting processor for:", op)
    try {
        processor = get_processor(op)
        result = processor(10, 5)
        print("  Result: 10", op, "5 =", result)
    } catch (default_proc) {
        print("  Using default processor (subtract)")
        result = default_proc(10, 5)
        print("  Result: 10 - 5 =", result)
    }
}
print()

# Test 8: Exception Handling Still Works Normally
print("Test 8: Normal Exception Handling Still Works")

try {
    throw IndexError("Array index out of bounds")
} catch (e as IndexError) {
    print("âœ“ IndexError caught correctly:", e.message)
    print("  Type:", e.type)
}

try {
    throw ValueError("Invalid input value")
} catch (e as ValueError) {
    print("âœ“ ValueError caught correctly:", e.message)
    print("  Type:", e.type)
}

# Demonstrate type-specific catching still works
try {
    throw "This is just a string, not an exception"
} catch (e as RuntimeError) {
    print("This won't be reached - string doesn't match RuntimeError")
} catch (str_val) {
    print("âœ“ String caught in generic catch:", str_val)
}
print()

print("=== Comprehensive Throw Test Complete ===")
print()
print("ðŸŽ‰ KEY FINDINGS:")
print("âœ“ Any object can be thrown: primitives, collections, functions, classes")
print("âœ“ Caught objects retain their original type and all properties")
print("âœ“ Full operations available on caught objects (math, string ops, etc.)")
print("âœ“ Typed exception catching (with 'as') only matches real exception objects")
print("âœ“ Non-exception objects fall through to generic catch blocks")
print("âœ“ This enables powerful error handling patterns and control flow")
print("âœ“ Normal exception handling continues to work as expected")
print("âœ“ Maximum flexibility - throw whatever makes sense for your use case!")
