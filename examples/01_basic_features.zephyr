# Zephyr Basic Language Features
# This file demonstrates the fundamental features of Zephyr

print("=== Zephyr Basic Features Demo ===")
print("")

# ============================================================================
# Variables and Data Types
# ============================================================================

print("1. Variables and Data Types")
print("===========================")

# Numbers (integers and floats)
x = 10
y = 20.5
print("Integer x =", x)
print("Float y =", y)

# ============================================================================
# Constant Declarations
# ============================================================================

print("2. Constant Declarations")
print("========================")

# Basic const declarations with different types
const PI = 3.14159
const GREETING = "Hello, Const!"
const MAX_USERS = 100
const IS_ENABLED = true
const EMPTY_LIST = []
const CONFIG = {"debug": true, "timeout": 30}

print("Mathematical constant PI =", PI)
print("String constant GREETING =", GREETING)
print("Integer constant MAX_USERS =", MAX_USERS)
print("Boolean constant IS_ENABLED =", IS_ENABLED)
print("List constant EMPTY_LIST =", EMPTY_LIST)
print("Dictionary constant CONFIG =", CONFIG)

# Constants in different scopes
const GLOBAL_SETTING = "production"

func test_local_constants() {
    const LOCAL_VALUE = 42
    const LOCAL_NAME = "LocalScope"
    print("Local constant LOCAL_VALUE =", LOCAL_VALUE)
    print("Local constant LOCAL_NAME =", LOCAL_NAME)
    print("Access to global constant =", GLOBAL_SETTING)
}

test_local_constants()

print("")

# ============================================================================
# Const Immutability Testing
# ============================================================================

print("2.1. Const Immutability Protection")
print("===================================")

# Attempting to reassign a constant (should cause a runtime error)
try {
    PI = 3.0
} catch e {
    print("✓ Assignment protection:", e)
}

# Attempting compound assignment on a constant (should cause a runtime error)
const COUNT = 10
print("Constant COUNT =", COUNT)
try {
    COUNT += 5
} catch e {
    print("✓ Compound assignment protection:", e)
}

try {
    COUNT -= 2
} catch e {
    print("✓ Compound subtraction protection:", e)
}

try {
    COUNT *= 3
} catch e {
    print("✓ Compound multiplication protection:", e)
}

# Attempting increment/decrement on a constant (should cause a runtime error)
const VALUE = 5
print("Constant VALUE =", VALUE)
try {
    VALUE++
} catch e {
    print("✓ Postfix increment protection:", e)
}
try {
    ++VALUE
} catch e {
    print("✓ Prefix increment protection:", e)
}
try {
    VALUE--
} catch e {
    print("✓ Postfix decrement protection:", e)
}
try {
    --VALUE
} catch e {
    print("✓ Prefix decrement protection:", e)
}

# Test const with complex data types
const USER_DATA = {"name": "Alice", "age": 30, "roles": ["admin", "user"]}
print("Const complex data =", USER_DATA)

# Note: The const protection applies to the variable binding, not deep immutability
# This means the reference is const, but the contents can still be modified
USER_DATA["age"] = 31  # This works - we're modifying contents, not reassigning
print("Modified const data contents =", USER_DATA)

try {
    USER_DATA = {"different": "object"}  # This should fail - reassignment
} catch e {
    print("✓ Const object reassignment protection:", e)
}

# ============================================================================
# Explicit Typing (Optional Type Annotations)
# ============================================================================

print("2.2. Explicit Typing")
print("=====================")

# Basic explicit type declarations using colon syntax
name : string = "Alice"
age : int = 25
score : float = 98.5
active : bool = true

print("Explicitly typed string name =", name)
print("Explicitly typed int age =", age)
print("Explicitly typed float score =", score)
print("Explicitly typed bool active =", active)

# Typed constants
const MAX_SCORE : int = 100
const APP_NAME : string = "Zephyr"
const PI_VALUE : float = 3.14159

print("Typed constant MAX_SCORE =", MAX_SCORE)
print("Typed constant APP_NAME =", APP_NAME)
print("Typed constant PI_VALUE =", PI_VALUE)

# None assignment with type retention
typed_var : string = "initial"
print("Before none assignment:", typed_var)

typed_var = none  # Allowed - retains string type constraint
print("After none assignment:", typed_var)

typed_var = "restored"  # Works - correct type
print("After restoration:", typed_var)

# Type validation - this will cause runtime errors
try {
    name = 42  # Error: cannot assign int to string variable
} catch e {
    print("✓ Type validation:", e)
}

try {
    age = "twenty-five"  # Error: cannot assign string to int variable
} catch e {
    print("✓ Type validation:", e)
}

print("")

# ============================================================================
# Dynamic Variables (Standard Behavior)
# ============================================================================

print("2.3. Dynamic Variables")
print("=======================")

# Strings
# Strings
message = "Hello, Zephyr!"
print("String message =", message)
print("Length of message:", len(message))

# String indexing
print("First character:", message[0])
print("Last character:", message[-1])
print("Character at index 7:", message[7]) # 'Z'

# String compound operations
greeting = "Hello"
greeting += " World"  # String concatenation
greeting *= 2         # String repetition: "Hello WorldHello World"

# Booleans
is_awesome = true
is_boring = false
print("Boolean is_awesome =", is_awesome)
print("Boolean is_boring =", is_boring)

print("")

# ============================================================================
# Arithmetic Operations
# ============================================================================

print("2. Arithmetic Operations")
print("=========================")

sum = x + y
difference = y - x
product = x * 2
quotient = y / 2

print("x + y =", sum)
print("y - x =", difference)
print("x * 2 =", product)
print("y / 2 =", quotient)

# Modulo operations
remainder1 = 17 % 5
remainder2 = 23 % 7
float_remainder = 15.5 % 4.2
print("17 % 5 =", remainder1)
print("23 % 7 =", remainder2)
print("15.5 % 4.2 =", float_remainder)

# Negative numbers
neg_x = -15
neg_y = -7.5
print("Negative integer =", neg_x)
print("Negative float =", neg_y)

# Arithmetic with negatives
neg_sum = neg_x + 20
neg_product = neg_x * -2
print("(-15) + 20 =", neg_sum)
print("(-15) * (-2) =", neg_product)

# String multiplication (repetition)
repeated_char = "=" * 20
repeated_word = "Hello" * 3
print("String repetition: \"=\" * 20 =", repeated_char)
print("String repetition: \"Hello\" * 3 =", repeated_word)

# String multiplication with variables
count = 5
pattern = "*" * count
print("Pattern with variable: \"*\" * 5 =", pattern)

# Both directions work
reverse_pattern = 4 * "ABC"
print("Reverse multiplication: 4 * \"ABC\" =", reverse_pattern)

# Power operator (**)
print("2 ** 3:", 2 ** 3)
print("3 ** 2:", 3 ** 2)
print("2.5 ** 2:", 2.5 ** 2)

print("")

# ============================================================================
# Comparison Operations
# ============================================================================


print("3. Comparison Operations")
print("=========================")

print("x == 10:", x == 10)
print("x != 5:", x != 5)
print("x < y:", x < y)
print("x <= 10:", x <= 10)
print("y > x:", y > x)
print("y >= 20:", y >= 20)

# Identity operator (is)
class A {}
a = A()
b = a
c = A()

print("a is b:", a is b)
print("a is c:", a is c)

print("")

# ============================================================================
# Logical Operations
# ============================================================================

print("4. Logical Operations")
print("======================")

a = true
b = false

print("a and b:", a and b)
print("a or b:", a or b)
print("not a:", not a)
print("not b:", not b)

# Alternative syntax
print("a && b:", a && b)
print("a || b:", a || b)
print("!a:", !a)

# The 'or' operator can be used to provide default values
print("\nLogical 'or' for default values:")
x = none
y = x or 2
print("x = none; y = x or 2; y =", y) # Expected: 2

a = 0
b = a or "hello"
print("a = 0; b = a or \"hello\"; b =", b) # Expected: "hello"

c = ""
d = c or [1, 2]
print("c = \"\"; d = c or [1, 2]; d =", d) # Expected: [1, 2]

empty_dict = {}
filled_value = empty_dict or {"default": "value"}
print("empty_dict = {}; filled_value = empty_dict or {\"default\": \"value\"}; filled_value =", filled_value) # Expected: {"default": "value"}

# If the first operand is truthy, it is returned
e = "not none"
f = e or 10
print("e = \"not none\"; f = e or 10; f =", f) # Expected: "not none"

g = 5
h = g or "world"
print("g = 5; h = g or \"world\"; h =", h) # Expected: 5

print("")

# ============================================================================
# Nullish Coalescing Operator (??)
# ============================================================================

print("4.2. Nullish Coalescing Operator (??)")
print("======================================")

# The '??' operator provides a default value only if the left operand is 'none'.
# It does NOT coalesce for other falsy values like 0, empty strings, or empty lists.

x = none
y = x ?? "default_value"
print("x = none; y = x ?? \"default_value\"; y =", y) # Expected: "default_value"

a = 0
b = a ?? "default_value"
print("a = 0; b = a ?? \"default_value\"; b =", b) # Expected: 0

c = ""
d = c ?? "default_value"
print("c = \"\"; d = c ?? \"default_value\"; d =", d) # Expected: ""

empty_list = []
filled_list = empty_list ?? [10, 20]
print("empty_list = []; filled_list = empty_list ?? [10, 20]; filled_list =", filled_list) # Expected: []

# Chaining multiple ?? operators
val1 = none
val2 = none
val3 = "final_value"
result = val1 ?? val2 ?? val3
print("val1 ?? val2 ?? val3 =", result) # Expected: "final_value"

val4 = 0
result2 = val1 ?? val4 ?? val3
print("val1 ?? val4 ?? val3 =", result2) # Expected: 0

print("")




# ============================================================================
# Pipe Operator (|>)
# ============================================================================

print("4.3. Pipe Operator (|>)")
print("========================")

func add_one(x) {
    return x + 1
}

func multiply_by_two(x) {
    return x * 2
}

func to_string(x) {
    return str(x)
}

func prefix_with_hello(s) {
    return "Hello, " + s
}

# Example 1: Simple chain
result_piped = 5 |> add_one |> multiply_by_two |> to_string
print("Piped result (5 |> add_one |> multiply_by_two |> to_string):", result_piped) # Expected: "12"

# Example 2: More complex transformation
data = "world"
final_greeting = data |> prefix_with_hello |> to_string
print("Final greeting ('world' |> prefix_with_hello |> to_string):", final_greeting) # Expected: "Hello, world"

# Example 3: Chaining with lambdas
transform_chain = 10 |> (x -> x + 5) |> (y -> y * 3) |> (z -> str(z) + "!")
print("Lambda chain (10 |> (x -> x + 5) |> (y -> y * 3) |> (z -> str(z) + \"!\")):", transform_chain) # Expected: "45!"

# Example 4: Using with built-in functions (len)
len_of_string = "Zephyr" |> len
print("Length of \"Zephyr\" |> len:", len_of_string) # Expected: 6

print("")




# ============================================================================
# Boolean Conversion
# ============================================================================

print("5. Boolean Conversion")
print("=====================")

# Numbers: 0 is false, everything else is true
print("Boolean value of 0:", 0 ? "true" : "false")
print("Boolean value of 10:", 10 ? "true" : "false")
print("Boolean value of -1:", -1 ? "true" : "false")
print("Boolean value of 0.0:", 0.0 ? "true" : "false")
print("Boolean value of 0.5:", 0.5 ? "true" : "false")

# Boolean conversion in conditional statements
if 10 {
    print("Ten is truthy in if statement")
}

if 0 {
    print("Zero is truthy (should not print)")
} else {
    print("Zero is falsy in if statement")
}

if 0.0 {
    print("Zero point zero is truthy (should not print)")
} else {
    print("Zero point zero is falsy in if statement")
}

if 0.5 {
    print("Zero point five is truthy in if statement")
}

if -1 {
    print("Negative one is truthy in if statement")
}

# Boolean conversion with logical NOT
print("Logical NOT of 0:", !0)
print("Logical NOT of 1:", !1)
print("Logical NOT of 0.0:", !0.0)
print("Logical NOT of 0.5:", !0.5)

print("")

# ============================================================================
# Ternary Operator
# ============================================================================

print("6. Ternary Operator")
print("===================")

age = 18
status = age >= 18 ? "adult" : "minor"
print("Age:", age, "- Status:", status)

# Nested ternary
test_score = 85
grade = test_score >= 90 ? "A" : (test_score >= 80 ? "B" : (test_score >= 70 ? "C" : "F"))
print("Score:", test_score, "- Grade:", grade)

print("")

# ============================================================================
# Control Flow - If/Else Statements
# ============================================================================

print("7. Control Flow - If/Else")
print("==========================")

temperature = 25

if temperature > 30 {
    print("It's hot!")
} else if temperature > 20 {
    print("It's warm!")
} else if temperature > 10 {
    print("It's cool!")
} else {
    print("It's cold!")
}

print("")

# ============================================================================
# Control Flow - While Loops
# ============================================================================

print("8. While Loops")
print("===============")

counter = 1
print("Counting from 1 to 5:")
while counter <= 5 {
    print("Count:", counter)
    counter = counter + 1
}

print("")

# ============================================================================
# Control Flow - For Loops
# ============================================================================

print("9. For Loops")
print("=============")

print("For loop from 0 to 4:")
for i = 0; i < 5; i = i + 1 {
    print("i =", i)
}

print("")

# ============================================================================
# Control Flow - Break and Continue
# ============================================================================

print("10. Break and Continue")
print("======================")

print("Loop with break and continue:")
for i = 0; i < 10; i = i + 1 {
    if i == 3 {
        print("Skipping", i, "with continue")
        continue
    }
    if i == 7 {
        print("Breaking at", i)
        break
    }
    print("Processing", i)
}

print("")

# ============================================================================
# Comments
# ============================================================================

print("11. Comments")
print("=============")

# This is a single-line comment
print("Comments start with # and go to the end of the line")
# You can have multiple comment lines
print("Check the source code to see comment examples")

# Comments can appear at the end of lines
x_comment = 10 # This is a trailing comment

# Comments can be used to disable code
# disabled_variable = 20  # This line is commented out

# Comments help document your code
final_value = x_comment + 5  # Calculate final value based on x_comment
print("Value with trailing comment:", final_value)

print("")

# ============================================================================
# Type Checking
# ============================================================================

print("12. Type Checking")
print("==================")

print("Type of 42:", type(42))
print("Type of 3.14:", type(3.14))
print("Type of \"hello\":", type("hello"))
print("Type of true:", type(true))

print("")

# ============================================================================
# Built-in Functions
# ============================================================================

print("13. Built-in Functions")
print("======================")

# String, integer, and float conversions
num_int = 123
num_float = 45.67
str_val = "890"

print("str(123):", str(num_int))
print("int(\"890\"):", int(str_val))
print("float(\"45.67\"):", float("45.67"))
print("float(123):", float(num_int))
print("int(45.67):", int(num_float))

# Length function
print("len(\"hello\"):", len("hello"))
print("len([1, 2, 3]):", len([1, 2, 3]))
print("len({\"a\": 1, \"b\": 2}):", len({"a": 1, "b": 2}))

# List operations
test_list = [10, 20]
print("test_list before append:", test_list)
append(test_list, 30)
print("test_list after append:", test_list)

popped_val = pop(test_list, 1)
print("popped value:", popped_val)
print("test_list after pop:", test_list)

# Dictionary operations
test_dict = {"name": "Zephyr", "version": 1.0}
print("keys(test_dict):", keys(test_dict))
print("values(test_dict):", values(test_dict))

print("")

# ============================================================================
# Switch Statements
# ============================================================================

print("14. Switch Statements")
print("=====================")

# Switch with integer
x = 10
result = ""
switch x {
    case 5: {
        result = "five"
    }
    case 10: {
        result = "ten"
    }
    case 15: {
        result = "fifteen"
    }
    default: {
        result = "other"
    }
}
print("x is", result)

# Switch with string
day = "Wednesday"
message = ""
switch day {
    case "Monday": {
        message = "Start of the work week"
    }
    case "Tuesday": {
        message = "Tuesday blues"
    }
    case "Wednesday": {
        message = "Hump day!"
    }
    case "Friday": {
        message = "TGIF!"
    }
    default: {
        message = "Just another day"
    }
}
print("Day message:", message)

print("")

### Switch Statements with Fall-through

print("14.1. Switch Statements with Fall-through")
print("==========================================")

# Zephyr's `switch` statements support fall-through behavior, similar to C/C++.
# If a `case` matches, execution continues into subsequent `case` blocks until a `break`
# statement is encountered or the end of the `switch` block is reached.

value = 1

switch value {
    case 1:
        print("Case 1 executed.")
        # No break, so execution falls through to the next case
    case 2:
        print("Case 2 executed (due to fall-through or direct match).")
        break # This break prevents further fall-through
    case 3:
        print("Case 3 executed. This should not be printed if break in Case 2 works.")
    default:
        print("Default case executed. This should not be printed if break in Case 2 works.")
}

print("---")

value = 2

switch value {
    case 1:
        print("Case 1 executed. This should not be printed for value = 2.")
    case 2:
        print("Case 2 executed (direct match).")
        # No break, so execution falls through to the next case
    case 3:
        print("Case 3 executed (due to fall-through).")
    default:
        print("Default case executed (due to fall-through).")
}

print("---")

value = 4

switch value {
    case 1:
        print("Case 1 executed.")
    case 2:
        print("Case 2 executed.")
    case 3:
        print("Case 3 executed.")
    default:
        print("Default case executed (no match, so direct to default).")
}

print("")

# ============================================================================
# Error Handling
# ============================================================================

print("15. Error Handling")
print("==================")

# Try-catch for division by zero
try {
    result = 10 / 0
    print("This won't print")
} catch e {
    print("Caught an error:", e)
}

# Try-catch for invalid operations
try {
    invalid_list = [1, 2, 3]
    value = invalid_list[10]  # Index out of bounds
} catch e {
    print("Caught index error:", e)
}

print("Program continues after error handling")

print("")

# ============================================================================
# Unary Operators
# ============================================================================

print("16. Unary Operators")
print("===================")

# Unary plus
positive_num = +10
print("Unary plus +10:", positive_num)

# Unary minus
negative_num = -5
print("Unary minus -5:", negative_num)

# Logical NOT
bool_true = true
bool_false = false
print("Logical NOT !true:", !bool_true)
print("Logical NOT !false:", !bool_false)

# Multiple unary operators
double_negative = -(-10)
print("Double negative -(-10):", double_negative)

triple_positive = +(+(+5))
print("Triple positive +(+(+5)):", triple_positive)

# Unary operators with variables
x = 15
print("Original x:", x)
print("Unary minus -x:", -x)
print("Logical NOT !x:", !x)  # Should be false since x is truthy

# Unary operators in expressions
result = -(-10)  # Should be 10
print("Negative of negative: -(-10) =", result)

print("")

# ============================================================================
# Membership Operator (in)
# ============================================================================

print("17. Membership Operator (in)")
print("=============================")

# 'in' operator with strings
print("'a' in 'abc':", 'a' in 'abc')
print("'d' in 'abc':", 'd' in 'abc')

# 'in' operator with lists
my_list = [1, 2, 3]
print("2 in [1, 2, 3]:", 2 in my_list)
print("4 in [1, 2, 3]:", 4 in my_list)

# 'in' operator with dictionaries
my_dict = {"a": 1, "b": 2}
print("'a' in {'a': 1, 'b': 2}:", 'a' in my_dict)
print("'c' in {'a': 1, 'b': 2}:", 'c' in my_dict)

print("")

print("")
print("=== Basic Features Demo Complete ===")
