# Test for Throwing Non-Exception Objects
# This tests what happens when we throw objects that aren't exception types

print("=== Testing Throwing Non-Exception Objects ===")
print()

# Test 1: Throwing primitive types
print("Test 1: Throwing Primitive Types")

print("Throwing integer 42:")
try {
    throw 42
} catch (val) {
    print("Caught:", val)
    print("Type:", type(val))
    print("Can use as number:", val + 8, "=", val + 8)
    print("Can convert to string:", str(val))
}
print()

print("Throwing float 3.14:")
try {
    throw 3.14
} catch (val) {
    print("Caught:", val)
    print("Type:", type(val))
    print("Can use as float:", val * 2, "=", val * 2)
}
print()

print("Throwing string 'Hello World':")
try {
    throw "Hello World"
} catch (val) {
    print("Caught:", val)
    print("Type:", type(val))
    print("String length:", len(val))
    print("Uppercase:", val.upper())
}
print()

print("Throwing boolean true:")
try {
    throw true
} catch (val) {
    print("Caught:", val)
    print("Type:", type(val))
    print("Logical NOT:", not val)
}
print()

print("Throwing none:")
try {
    throw none
} catch (val) {
    print("Caught:", val)
    print("Type:", type(val))
    print("Is none:", val == none)
}
print()

# Test 2: Throwing collections
print("Test 2: Throwing Collections")

print("Throwing list [1, 2, 3]:")
try {
    throw [1, 2, 3]
} catch (val) {
    print("Caught:", val)
    print("Type:", type(val))
    print("Length:", len(val))
    print("First element:", val[0])
    print("Can iterate:")
    for item in val {
        print("  -", item)
    }
}
print()

print("Throwing dictionary {name: 'Alice', age: 30}:")
try {
    throw {"name": "Alice", "age": 30}
} catch (val) {
    print("Caught:", val)
    print("Type:", type(val))
    print("Name:", val["name"])
    print("Age:", val["age"])
}
print()

# Test 3: Throwing custom objects/classes
print("Test 3: Throwing Custom Objects")

class CustomError {
    func __init__(message, code) {
        self.message = message
        self.code = code
    }

    func to_string() {
        return "CustomError(" + str(self.code) + "): " + self.message
    }
}

class Person {
    func __init__(name, age) {
        self.name = name
        self.age = age
    }

    func greet() {
        return "Hello, I'm " + self.name + " and I'm " + str(self.age) + " years old"
    }
}

print("Throwing custom error object:")
try {
    error_obj = CustomError("Something went wrong", 500)
    throw error_obj
} catch (val) {
    print("Caught:", val)
    print("Type:", type(val))
    print("Message:", val.message)
    print("Code:", val.code)
    print("String representation:", val.to_string())
}
print()

print("Throwing person object:")
try {
    person = Person("Bob", 25)
    throw person
} catch (val) {
    print("Caught:", val)
    print("Type:", type(val))
    print("Name:", val.name)
    print("Age:", val.age)
    print("Greeting:", val.greet())
}
print()

# Test 4: Mixing exception and non-exception types
print("Test 4: Mixed Exception Types in Same Try-Catch")

func throw_random_type(type_name) {
    if type_name == "exception" {
        throw RuntimeError("This is a real exception")
    } else if type_name == "int" {
        throw 999
    } else if type_name == "string" {
        throw "This is just a string"
    } else if type_name == "list" {
        throw ["error", "data", 123]
    } else {
        throw {"type": "unknown", "data": "mystery"}
    }
}

test_types = ["exception", "int", "string", "list", "dict"]

for test_type in test_types {
    print("Throwing type:", test_type)
    try {
        throw_random_type(test_type)
    } catch (val) {
        print("  Caught:", val)
        print("  Object type:", type(val))

        # Check if it has exception-like properties
        if hasattr(val, "type") and hasattr(val, "message") {
            print("  Exception type:", val.type)
            print("  Exception message:", val.message)
        } else {
            print("  Not an exception object - direct value access")
        }
    }
    print("  ---")
}
print()

# Test 5: Typed catches with non-exception objects
print("Test 5: Typed Catches with Non-Exception Objects")

print("Trying to catch integer as RuntimeError:")
try {
    throw 42
} catch (e as RuntimeError) {
    print("Caught as RuntimeError:", e)
} catch (e) {
    print("Caught as generic:", e, "- type:", type(e))
}
print()

print("Trying to catch string as ValueError:")
try {
    throw "just a string"
} catch (e as ValueError) {
    print("Caught as ValueError:", e)
} catch (e) {
    print("Caught as generic:", e, "- type:", type(e))
}
print()

# Test 6: Mathematical and logical operations on caught objects
print("Test 6: Operations on Caught Non-Exception Objects")

print("Mathematical operations with caught integer:")
try {
    throw 15
} catch (num) {
    print("Original:", num)
    print("Addition:", num + 10)
    print("Multiplication:", num * 2)
    print("Division:", num / 3)
    print("Modulo:", num % 4)
    print("Comparison:", num > 10)
}
print()

print("String operations with caught string:")
try {
    throw "hello world"
} catch (text) {
    print("Original:", text)
    print("Length:", len(text))
    print("Upper case:", text.upper())
    print("Contains 'world':", "world" in text)
    print("Repeated:", text * 2)
}
print()

# Test 7: Function objects and lambdas
print("Test 7: Throwing Functions and Lambdas")

func sample_function() {
    return "I'm a function!"
}

print("Throwing function object:")
try {
    throw sample_function
} catch (func_obj) {
    print("Caught function:", func_obj)
    print("Type:", type(func_obj))
    print("Calling function:", func_obj())
}
print()

print("Throwing lambda:")
try {
    my_lambda = func(x) { return x * x }
    throw my_lambda
} catch (lambda_obj) {
    print("Caught lambda:", lambda_obj)
    print("Type:", type(lambda_obj))
    print("Calling lambda with 5:", lambda_obj(5))
}
print()

print("=== Non-Exception Throwing Test Complete ===")
print("Key findings:")
print("✓ Any object can be thrown, not just exception objects")
print("✓ Caught objects retain their original type and properties")
print("✓ All normal operations work on caught non-exception objects")
print("✓ Typed catches (with 'as') only match actual exception types")
print("✓ Non-exception objects fall through to generic catch blocks")
print("✓ Functions, classes, collections - everything can be thrown")
print("✓ This provides maximum flexibility for error handling patterns")
